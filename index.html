Share

M
You said:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Heart</title>
    <style>
        body { text-align: center; margin: 0; overflow: hidden; background-color: #ffccd5; }
        canvas { display: block; position: relative; background-color: #ffebef; }
        #score { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 24px; font-family: Arial, sans-serif; font-weight: bold; color: red; }
        #message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; font-family: Arial, sans-serif; font-weight: bold; color: red; display: none; }
        #retry { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); font-size: 20px; font-family: Arial, sans-serif; font-weight: bold; color: white; background-color: red; border: none; padding: 10px 20px; cursor: pointer; display: none; }
        #personalizedMessage { position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%); font-size: 28px; font-family: Arial, sans-serif; font-weight: bold; color: red; display: none; }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="message"></div>
    <div id="personalizedMessage"></div>
    <button id="retry" onclick="restartGame()">Retry</button>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const messageBox = document.getElementById("message");
        const retryButton = document.getElementById("retry");
        const personalizedMessageBox = document.getElementById("personalizedMessage");
        canvas.width = 400;
        canvas.height = 600;

        const bird = { x: 50, y: 300, vy: 0, trail: [] };
        const gravity = 0.5;
        const jump = -8;
        let pipes = [];
        let collectibles = [];
        const pipeWidth = 50;
        const pipeGap = 150;
        let score = 0;
        let gameOver = false;
        let hearts = [];
        const messages = ["I love you", "You're the best", "You're my everything", "Don't talk bad about yourself", "You're so cute", "Keep going"];
        const personalizedMessages = [
            "Dell, you light up my world!", 
            "You're the most beautiful person inside and out!", 
            "Every day with you is a dream come true!", 
            "You're my happiness, my heart, my love!", 
            "I am so lucky to have you!", 
            "Forever and always, you have my heart!"
        ];

        function spawnPipes() {
            pipes.push({ x: canvas.width, y: Math.random() * 200 + 100 });
        }

       document.addEventListener("touchstart", () => {
    bird.vy = jump;
});


        function updateScore() {
            document.getElementById("score").innerText = "Score: " + score;
            if (score % 5 === 0 && score !== 0) {
                fillWithHearts();
                showPersonalizedMessage();
                setTimeout(() => { hearts = []; }, 1500);
            }
        }

        function showMessage() {
            const message = messages[Math.floor(Math.random() * messages.length)];
            messageBox.innerText = message;
            messageBox.style.display = "block";
            setTimeout(() => messageBox.style.display = "none", 2000);
        }

        function showPersonalizedMessage() {
            const message = personalizedMessages[Math.floor(Math.random() * personalizedMessages.length)];
            personalizedMessageBox.innerText = message;
            personalizedMessageBox.style.display = "block";
            setTimeout(() => personalizedMessageBox.style.display = "none", 2500);
        }

        function checkCollision(pipe) {
            if (
                bird.x + 10 > pipe.x && bird.x - 10 < pipe.x + pipeWidth &&
                (bird.y - 10 < pipe.y || bird.y + 10 > pipe.y + pipeGap)
            ) {
                endGame();
            }
        }

        function endGame() {
            gameOver = true;
            retryButton.style.display = "block";
        }

        function restartGame() {
            bird.y = 300;
            bird.vy = 0;
            bird.trail = [];
            pipes = [];
            collectibles = [];
            score = 0;
            gameOver = false;
            hearts = [];
            retryButton.style.display = "none";
            spawnPipes();
            update();
        }

        function fillWithHearts() {
            for (let i = 0; i < 15; i++) {
                hearts.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vy: Math.random() * 2 + 1 });
            }
        }

        function drawHeart(x, y, size) {
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.moveTo(x, y + size / 4);
            ctx.bezierCurveTo(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
            ctx.bezierCurveTo(x + size, y + size / 3, x + size / 2, y - size / 2, x, y + size / 4);
            ctx.fill();
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            bird.vy += gravity;
            bird.y += bird.vy;
            
            bird.trail.push({ x: bird.x, y: bird.y });
            if (bird.trail.length > 10) bird.trail.shift();
            
            bird.trail.forEach((t, i) => {
                drawHeart(t.x, t.y, 5 + i);
            });
            
            drawHeart(bird.x, bird.y, 20);

            if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 200) {
                spawnPipes();
            }

            pipes.forEach((pipe, i) => {
                pipe.x -= 2;
                if (pipe.x + pipeWidth < 0) {
                    pipes.splice(i, 1);
                    score++;
                    collectibles.push({ x: pipe.x + pipeWidth / 2, y: pipe.y + pipeGap / 2 });
                }
                ctx.fillStyle = "pink";
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.y);
                ctx.fillRect(pipe.x, pipe.y + pipeGap, pipeWidth, canvas.height - pipe.y - pipeGap);
                checkCollision(pipe);
            });

            updateScore();
            if (!gameOver) requestAnimationFrame(update);
        }
        spawnPipes();
        update();
    </script>
</body>
</html> 





